package com.yc.core.cqrs.application.service.command;

import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import com.yc.core.cqrs.application.service.AggregateStore;
import com.yc.core.cqrs.application.service.command.handler.DefaultCommandHandlerImpl;
import com.yc.core.cqrs.application.service.event.handler.SyncEventHandler;
import com.yc.core.cqrs.application.usecase.CommandHandler;

import br.com.comigo.core.domain.Aggregate;
import br.com.comigo.core.domain.command.Command;
import br.com.comigo.core.domain.event.Event;
import br.com.comigo.core.domain.event.EventWithId;

import java.util.List;
import java.util.UUID;

/**
 * Essa é uma classe que tem por finalidade processar comandos e, ao fim,
 * disparar eventos. Importante: é uma classe genérica e, assim, desobriga o
 * desenvolvedor de implementar o mesmo código. Ela descobrirá, em tempo de
 * execução, qual o comando, qual o handler a ser utilizado, qual o agregate a
 * ser utilizado e qual o evento a ser disparado.
 * 
 * Para que isso funcione é importante que o usuario dessa implementação seja
 * capaz especilizar e implementar o handler de comando e o handler de evento.
 * 
 */
@Transactional
@Component
@RequiredArgsConstructor
@Slf4j
public class CommandProcessor {

    private final AggregateStore aggregateStore;
    private final List<CommandHandler<? extends Command>> commandHandlers;
    private final DefaultCommandHandlerImpl defaultCommandHandler;
    private final List<SyncEventHandler> aggregateChangesHandlers;

    @Value("${db.schema}")
    private String schemaName;

    public Aggregate process(@NonNull Command command) {
        log.info(" >>> start command processing [{}]", command);

        final String aggregateType = command.getAggregateType();
        final UUID aggregateId = command.getAggregateId();

        /**
         * A seguir, o sistema deverá recuperar o agregado, se existir. Com isso, se
         * existir evetnos associatdos ao agregado, reconstituí-lo a partir dos eventos
         * registrados (cada evento recurperado será novamente processado na ordem em
         * que foi registrado).
         * 
         */
        log.info(" >>> try to read aggregate [{},{}]", aggregateType, aggregateId);
        Aggregate aggregate = this.aggregateStore.readAggregate(this.schemaName, aggregateType, aggregateId);
        log.info(" >>> aggregate readed [{}]", aggregate);

        this.commandHandlers.stream().filter(commandHandler -> commandHandler.getCommandType() == command.getClass())
                .findFirst().ifPresentOrElse(commandHandler -> {
                    log.info(" >>> try to handle command with handler {}.", commandHandler.getClass().getSimpleName());

                    /**
                     * Será tratado o novo comando associado ao agregado. Isso derivará o evento
                     * associado e, portanto, registrado.
                     * 
                     * Portanto, a partir daqui occurredEvents, na instancia do Aggregate concreto,
                     * não será mais um array vazio.
                     * 
                     */
                    log.info(" >>> try command handler [bv: {}, v: {}]", aggregate.getBaseVersion(), aggregate.getVersion());
                    commandHandler.handle(aggregate, command);
                    log.info(" >>> command handled.");
                }, () -> {
                    log.info(" >>> no specialized handler found, handling command {} with {}",
                            command.getClass().getSimpleName(),
                            CommandProcessor.this.defaultCommandHandler.getClass().getSimpleName());
                    CommandProcessor.this.defaultCommandHandler.handle(aggregate, command);
                });

        /**
         * Até aqui o estado alcançado pela execução do aggregate.process() não resultou
         * a persistência do estado do agregado.
         * 
         * Apenas o necessário para reconstituir o estado do agregado, anterior ao
         * momento ao evento atual, se já existe um agregado, foi realizado, além de,
         * por
         * fim, aplicar as mudanças atuais, carregadas no Command.
         * 
         */

        /**
         * Nesse momento o agregado está pronto para ser registrado na base de dados, e
         * o evento ser lançado.
         * 
         * No mínimo um evento já estará vinculado ao agregado.
         * 
         */
        List<EventWithId<Event>> events = this.aggregateStore.saveAggregate(this.schemaName, aggregate);
        log.info(" > events: {}", events);
        this.aggregateChangesHandlers.stream()
                .filter(handler -> handler.getAggregateType().equals(aggregateType))
                .forEach(handler -> {
                	log.info(" \n>>>>>> trying handle events {} for {}\n", events, aggregate);
                	handler.handleEvents(events, aggregate);
                });
        return aggregate;
    }
}
